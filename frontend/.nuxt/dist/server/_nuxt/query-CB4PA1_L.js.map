{"version":3,"file":"query-CB4PA1_L.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/@nuxt/content/dist/runtime/query/match/utils.js","../../../../node_modules/@nuxt/content/dist/runtime/query/query.js","../../../../node_modules/@nuxt/content/dist/runtime/utils/json.js","../../../../node_modules/@nuxt/content/dist/runtime/utils/query.js","../../../../node_modules/@nuxt/content/dist/runtime/composables/utils.js","../../../../node_modules/@nuxt/content/dist/runtime/legacy/composables/query.js"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\nimport { captureStackTrace } from \"errx\";\nimport { debounce } from \"perfect-debounce\";\nimport { hash } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { clientOnlySymbol } from \"../components/client-only.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\" && typeof args[0] !== \"object\" && !(typeof args[0] === \"function\" && typeof args[1] === \"function\")) {\n    args.unshift(autoKey);\n  }\n  let [_key, _handler, options = {}] = args;\n  const key = computed(() => toValue(_key));\n  if (typeof key.value !== \"string\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  const getDefault = () => asyncDataDefaults.value;\n  const getDefaultCachedData = (key2, nuxtApp2, ctx) => {\n    if (nuxtApp2.isHydrating) {\n      return nuxtApp2.payload.data[key2];\n    }\n    if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\n      return nuxtApp2.static.data[key2];\n    }\n  };\n  options.server ??= true;\n  options.default ??= getDefault;\n  options.getCachedData ??= getDefaultCachedData;\n  options.lazy ??= false;\n  options.immediate ??= true;\n  options.deep ??= asyncDataDefaults.deep;\n  options.dedupe ??= \"cancel\";\n  const functionName = options._functionName || \"useAsyncData\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(`[nuxt] \\`boolean\\` values are deprecated for the \\`dedupe\\` option of \\`${functionName}\\` and will be removed in the future. Use 'cancel' or 'defer' instead.`);\n  }\n  const currentData = nuxtApp._asyncData[key.value];\n  if (isDev && currentData) {\n    const warnings = [];\n    const values = createHash(_handler, options);\n    if (values.handler !== currentData._hash?.handler) {\n      warnings.push(`different handler`);\n    }\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\n      if (values[opt] !== currentData._hash[opt]) {\n        warnings.push(`different \\`${opt}\\` option`);\n      }\n    }\n    if (currentData._default.toString() !== options.default.toString()) {\n      warnings.push(`different \\`default\\` value`);\n    }\n    if (options.deep && isShallow(currentData.data)) {\n      warnings.push(`mismatching \\`deep\\` option`);\n    }\n    if (warnings.length) {\n      const distURL = import.meta.url.replace(/\\/app\\/.*$/, \"/app\");\n      const { source, line, column } = captureStackTrace().find((entry) => !entry.source.startsWith(distURL)) ?? {};\n      const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\n    }\n  }\n  const initialCachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\n  if (!nuxtApp._asyncData[key.value]?._init) {\n    nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialCachedData);\n  }\n  const asyncData = nuxtApp._asyncData[key.value];\n  asyncData._deps++;\n  const initialFetch = () => nuxtApp._asyncData[key.value].execute({ cause: \"initial\", dedupe: options.dedupe });\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    let unregister = function(key2) {\n      const data = nuxtApp._asyncData[key2];\n      if (data?._deps) {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n          data._init = false;\n          if (purgeCachedData) {\n            clearNuxtDataByKey(nuxtApp, key2);\n            data.execute = () => Promise.resolve();\n            nuxtApp._asyncData[key2].data.value = asyncDataDefaults.value;\n          }\n        }\n      }\n    };\n    const instance = getCurrentInstance();\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\n      instance.sp = [];\n    }\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || initialCachedData != null)) {\n      if (pendingWhenIdle) {\n        asyncData.pending.value = false;\n      }\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && !isWithinClientOnly && (nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    if (options.watch) {\n      const unsubExecute = watch(options.watch, () => {\n        asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\n      }, { flush: \"post\" });\n      if (hasScope) {\n        onScopeDispose(() => unsubExecute());\n      }\n    }\n    const unsubKey = watch(key, (newKey, oldKey) => {\n      const hasRun = nuxtApp._asyncData[oldKey]?.data.value !== asyncDataDefaults.value;\n      if (oldKey) {\n        unregister(oldKey);\n      }\n      if (!nuxtApp._asyncData[newKey]?._init) {\n        nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, options.getCachedData(newKey, nuxtApp, { cause: \"initial\" }));\n      }\n      nuxtApp._asyncData[newKey]._deps++;\n      if (options.immediate || hasRun) {\n        nuxtApp._asyncData[newKey].execute({ cause: \"initial\", dedupe: options.dedupe });\n      }\n    }, { flush: \"sync\" });\n    if (hasScope) {\n      onScopeDispose(() => {\n        unsubKey();\n        unregister(key.value);\n      });\n    }\n  }\n  const asyncReturn = {\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\n    refresh: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    execute: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    clear: () => clearNuxtDataByKey(nuxtApp, key.value)\n  };\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\n  Object.assign(asyncDataPromise, asyncReturn);\n  return asyncDataPromise;\n}\nfunction writableComputedRef(getter) {\n  return computed({\n    get() {\n      return getter()?.value;\n    },\n    set(value) {\n      const ref2 = getter();\n      if (ref2) {\n        ref2.value = value;\n      }\n    }\n  });\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\n  }\n  if (nuxtApp._asyncData[key]) {\n    const data = nuxtApp._asyncData[key];\n    data._deps++;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n          data._init = false;\n          if (purgeCachedData) {\n            clearNuxtDataByKey(nuxtApp, key);\n          }\n        }\n      });\n    }\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : unref(nuxtApp._asyncData[key]._default());\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\n    if (pendingWhenIdle) {\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    if (nuxtApp._asyncDataPromises[key]) {\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\nconst isDev = import.meta.dev;\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\n  nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(_handler));\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const _ref = options.deep ? ref : shallowRef;\n  const hasCachedData = initialCachedData != null;\n  const asyncData = {\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\n    error: toRef(nuxtApp.payload._errors, key),\n    status: shallowRef(\"idle\"),\n    execute: (opts = {}) => {\n      if (nuxtApp._asyncDataPromises[key]) {\n        if (isDefer(opts.dedupe ?? options.dedupe)) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        nuxtApp._asyncDataPromises[key].cancelled = true;\n      }\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\n        const cachedData = opts.cause === \"initial\" ? initialCachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\n        if (cachedData != null) {\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\n          asyncData.error.value = asyncDataDefaults.errorValue;\n          asyncData.status.value = \"success\";\n          return Promise.resolve(cachedData);\n        }\n      }\n      if (pendingWhenIdle) {\n        asyncData.pending.value = true;\n      }\n      asyncData.status.value = \"pending\";\n      const promise = new Promise(\n        (resolve, reject) => {\n          try {\n            resolve(handler(nuxtApp));\n          } catch (err) {\n            reject(err);\n          }\n        }\n      ).then(async (_result) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        let result = _result;\n        if (options.transform) {\n          result = await options.transform(_result);\n        }\n        if (options.pick) {\n          result = pick(result, options.pick);\n        }\n        if (import.meta.dev && import.meta.server && typeof result === \"undefined\") {\n          const stack = captureStackTrace();\n          const { source, line, column } = stack[stack.length - 1] ?? {};\n          const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\`) or the request may be duplicated on the client side.`);\n        }\n        nuxtApp.payload.data[key] = result;\n        asyncData.data.value = result;\n        asyncData.error.value = asyncDataDefaults.errorValue;\n        asyncData.status.value = \"success\";\n      }).catch((error) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        asyncData.error.value = createError(error);\n        asyncData.data.value = unref(options.default());\n        asyncData.status.value = \"error\";\n      }).finally(() => {\n        if (promise.cancelled) {\n          return;\n        }\n        if (pendingWhenIdle) {\n          asyncData.pending.value = false;\n        }\n        delete nuxtApp._asyncDataPromises[key];\n      });\n      nuxtApp._asyncDataPromises[key] = promise;\n      return nuxtApp._asyncDataPromises[key];\n    },\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\n    _default: options.default,\n    _deps: 0,\n    _init: true,\n    _hash: isDev ? createHash(_handler, options) : void 0,\n    _off: nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n      if (!keys || keys.includes(key)) {\n        await asyncData.execute({ cause: \"refresh:hook\" });\n      }\n    })\n  };\n  return asyncData;\n}\nfunction createHash(_handler, options) {\n  return {\n    handler: hash(_handler),\n    transform: options.transform ? hash(options.transform) : void 0,\n    pick: options.pick ? hash(options.pick) : void 0,\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\n  };\n}\n","export const get = (obj, path) => path.split(\".\").reduce((acc, part) => acc && acc[part], obj);\nconst _pick = (obj, condition) => Object.keys(obj).filter(condition).reduce((newObj, key) => Object.assign(newObj, { [key]: obj[key] }), {});\nexport const pick = (keys) => (obj) => keys && keys.length ? _pick(obj, (key) => keys.includes(key)) : obj;\nexport const omit = (keys) => (obj) => keys && keys.length ? _pick(obj, (key) => !keys.includes(key)) : obj;\nexport const apply = (fn) => (data) => Array.isArray(data) ? data.map((item) => fn(item)) : fn(data);\nexport const detectProperties = (keys) => {\n  const prefixes = [];\n  const properties = [];\n  for (const key of keys) {\n    if ([\"$\", \"_\"].includes(key)) {\n      prefixes.push(key);\n    } else {\n      properties.push(key);\n    }\n  }\n  return { prefixes, properties };\n};\nexport const withoutKeys = (keys = []) => (obj) => {\n  if (keys.length === 0 || !obj) {\n    return obj;\n  }\n  const { prefixes, properties } = detectProperties(keys);\n  return _pick(obj, (key) => !properties.includes(key) && !prefixes.includes(key[0]));\n};\nexport const withKeys = (keys = []) => (obj) => {\n  if (keys.length === 0 || !obj) {\n    return obj;\n  }\n  const { prefixes, properties } = detectProperties(keys);\n  return _pick(obj, (key) => properties.includes(key) || prefixes.includes(key[0]));\n};\nexport const sortList = (data, params) => {\n  const comperable = new Intl.Collator(params.$locale, {\n    numeric: params.$numeric,\n    caseFirst: params.$caseFirst,\n    sensitivity: params.$sensitivity\n  });\n  const keys = Object.keys(params).filter((key) => !key.startsWith(\"$\"));\n  for (const key of keys) {\n    data = data.sort((a, b) => {\n      const values = [get(a, key), get(b, key)].map((value) => {\n        if (value === null) {\n          return void 0;\n        }\n        if (value instanceof Date) {\n          return value.toISOString();\n        }\n        return value;\n      });\n      if (params[key] === -1) {\n        values.reverse();\n      }\n      return comperable.compare(values[0], values[1]);\n    });\n  }\n  return data;\n};\nexport const assertArray = (value, message = \"Expected an array\") => {\n  if (!Array.isArray(value)) {\n    throw new TypeError(message);\n  }\n};\nexport const ensureArray = (value) => {\n  return Array.isArray(value) ? value : [void 0, null].includes(value) ? [] : [value];\n};\n","import { ensureArray } from \"./match/utils.js\";\nconst arrayParams = [\"sort\", \"where\", \"only\", \"without\"];\nexport function createQuery(fetcher, opts = {}) {\n  const queryParams = {};\n  for (const key of Object.keys(opts.initialParams || {})) {\n    queryParams[key] = arrayParams.includes(key) ? ensureArray(opts.initialParams[key]) : opts.initialParams[key];\n  }\n  const $set = (key, fn = (v) => v) => {\n    return (...values) => {\n      queryParams[key] = fn(...values);\n      return query;\n    };\n  };\n  const resolveResult = (result) => {\n    if (opts.legacy) {\n      if (result?.surround) {\n        return result.surround;\n      }\n      if (!result) {\n        return result;\n      }\n      if (result?.dirConfig) {\n        result.result = {\n          _path: result.dirConfig?._path,\n          ...result.result,\n          _dir: result.dirConfig\n        };\n      }\n      return result?._path || Array.isArray(result) || !Object.prototype.hasOwnProperty.call(result, \"result\") ? result : result?.result;\n    }\n    return result;\n  };\n  const query = {\n    params: () => ({\n      ...queryParams,\n      ...queryParams.where ? { where: [...ensureArray(queryParams.where)] } : {},\n      ...queryParams.sort ? { sort: [...ensureArray(queryParams.sort)] } : {}\n    }),\n    only: $set(\"only\", ensureArray),\n    without: $set(\"without\", ensureArray),\n    where: $set(\"where\", (q) => [...ensureArray(queryParams.where), ...ensureArray(q)]),\n    sort: $set(\"sort\", (sort) => [...ensureArray(queryParams.sort), ...ensureArray(sort)]),\n    limit: $set(\"limit\", (v) => parseInt(String(v), 10)),\n    skip: $set(\"skip\", (v) => parseInt(String(v), 10)),\n    // find\n    find: () => fetcher(query).then(resolveResult),\n    findOne: () => fetcher($set(\"first\")(true)).then(resolveResult),\n    count: () => fetcher($set(\"count\")(true)).then(resolveResult),\n    // locale\n    locale: (_locale) => query.where({ _locale }),\n    withSurround: $set(\"surround\", (surroundQuery, options) => ({ query: surroundQuery, ...options })),\n    withDirConfig: () => $set(\"dirConfig\")(true)\n  };\n  if (opts.legacy) {\n    query.findSurround = (surroundQuery, options) => {\n      return query.withSurround(surroundQuery, options).find().then(resolveResult);\n    };\n    return query;\n  }\n  return query;\n}\n","export function jsonStringify(value) {\n  return JSON.stringify(value, regExpReplacer);\n}\nexport function jsonParse(value) {\n  return JSON.parse(value, regExpReviver);\n}\nfunction regExpReplacer(_key, value) {\n  if (value instanceof RegExp) {\n    return `--REGEX ${value.toString()}`;\n  }\n  return value;\n}\nfunction regExpReviver(_key, value) {\n  const withOperator = typeof value === \"string\" && value.match(/^--([A-Z]+) (.+)$/) || [];\n  if (withOperator[1] === \"REGEX\") {\n    const regex = withOperator[2]?.match(/\\/(.*)\\/([dgimsuy]*)$/);\n    return regex?.[1] ? new RegExp(regex[1], regex[2] || \"\") : value;\n  }\n  return value;\n}\n","import { getQuery, createError } from \"h3\";\nimport { jsonParse, jsonStringify } from \"./json.js\";\nconst parseJSONQueryParams = (body) => {\n  try {\n    return jsonParse(body);\n  } catch {\n    throw createError({ statusCode: 400, message: \"Invalid _params query\" });\n  }\n};\nexport const encodeQueryParams = (params) => {\n  let encoded = jsonStringify(params);\n  encoded = typeof Buffer !== \"undefined\" ? Buffer.from(encoded).toString(\"base64\") : btoa(encoded);\n  encoded = encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n  const chunks = encoded.match(/.{1,100}/g) || [];\n  return chunks.join(\"/\");\n};\nexport const decodeQueryParams = (encoded) => {\n  encoded = encoded.replace(/\\//g, \"\");\n  encoded = encoded.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  encoded = encoded.padEnd(encoded.length + (4 - encoded.length % 4) % 4, \"=\");\n  return parseJSONQueryParams(typeof Buffer !== \"undefined\" ? Buffer.from(encoded, \"base64\").toString() : atob(encoded));\n};\nconst memory = {};\nexport const getContentQuery = (event) => {\n  const { params } = event.context.params || {};\n  if (params) {\n    return decodeQueryParams(params.replace(/.json$/, \"\"));\n  }\n  const qid = event.context.params?.qid?.replace(/.json$/, \"\");\n  const query = getQuery(event) || {};\n  if (qid && query._params) {\n    memory[qid] = parseJSONQueryParams(decodeURIComponent(query._params));\n    if (memory[qid]?.where && !Array.isArray(memory[qid]?.where)) {\n      memory[qid].where = [memory[qid].where];\n    }\n    return memory[qid];\n  }\n  if (qid && memory[qid]) {\n    return memory[qid];\n  }\n  if (query._params) {\n    return parseJSONQueryParams(decodeURIComponent(query._params));\n  }\n  if (typeof query.only === \"string\" && query.only.includes(\",\")) {\n    query.only = query.only.split(\",\").map((s) => s.trim());\n  }\n  if (typeof query.without === \"string\" && query.without.includes(\",\")) {\n    query.without = query.without.split(\",\").map((s) => s.trim());\n  }\n  const where = query.where || {};\n  for (const key of [\"draft\", \"partial\", \"empty\"]) {\n    if (query[key] && [\"true\", \"false\"].includes(query[key])) {\n      where[key] = query[key] === \"true\";\n      delete query[key];\n    }\n  }\n  if (query.sort) {\n    query.sort = String(query.sort).split(\",\").map((s) => {\n      const [key, order] = s.split(\":\");\n      return [key, Number.parseInt(order || \"0\", 10)];\n    });\n  }\n  const reservedKeys = [\"partial\", \"draft\", \"only\", \"without\", \"where\", \"sort\", \"limit\", \"skip\"];\n  for (const key of Object.keys(query)) {\n    if (reservedKeys.includes(key)) {\n      continue;\n    }\n    query.where = query.where || {};\n    query.where[key] = query[key];\n  }\n  if (Object.keys(where).length > 0) {\n    query.where = [where];\n  } else {\n    delete query.where;\n  }\n  return query;\n};\n","import { withBase } from \"ufo\";\nimport { useContentPreview } from \"./preview.js\";\nimport { useRuntimeConfig, useRequestEvent } from \"#imports\";\nexport const withContentBase = (url) => withBase(url, useRuntimeConfig().public.content.api.baseURL);\nexport const useContentDisabled = () => {\n  console.warn(\"useContent is only accessible when you are using `documentDriven` mode.\");\n  console.warn(\"Learn more by visiting: https://content.nuxt.com/document-driven\");\n  throw new Error(\"useContent is only accessible when you are using `documentDriven` mode.\");\n};\nexport const navigationDisabled = () => {\n  console.warn(\"Navigation is only accessible when you enable it in module options.\");\n  console.warn(\"Learn more by visiting: https://content.nuxt.com/get-started/configuration#navigation\");\n  throw new Error(\"Navigation is only accessible when you enable it in module options.\");\n};\nexport const addPrerenderPath = (path) => {\n  const event = useRequestEvent();\n  if (event) {\n    event.node.res.setHeader(\n      \"x-nitro-prerender\",\n      [\n        event.node.res.getHeader(\"x-nitro-prerender\"),\n        path\n      ].filter(Boolean).join(\",\")\n    );\n  }\n};\nexport const shouldUseClientDB = () => {\n  const { experimental } = useRuntimeConfig().public.content;\n  if (import.meta.server) {\n    return false;\n  }\n  if (experimental.clientDB) {\n    return true;\n  }\n  return useContentPreview().isEnabled();\n};\n","import { joinURL, withLeadingSlash, withoutTrailingSlash } from \"ufo\";\nimport { hash } from \"ohash\";\nimport { createQuery } from \"../../query/query.js\";\nimport { encodeQueryParams } from \"../../utils/query.js\";\nimport { jsonStringify } from \"../../utils/json.js\";\nimport { addPrerenderPath, shouldUseClientDB, withContentBase } from \"../../composables/utils.js\";\nimport { useContentPreview } from \"../../composables/preview.js\";\nimport { useRuntimeConfig } from \"#imports\";\nexport const createQueryFetch = () => async (query) => {\n  const { content } = useRuntimeConfig().public;\n  const params = query.params();\n  const apiPath = content.experimental.stripQueryParameters ? withContentBase(`/query/${import.meta.dev ? \"_\" : `${hash(params)}.${content.integrity}`}/${encodeQueryParams(params)}.json`) : withContentBase(import.meta.dev ? \"/query\" : `/query/${hash(params)}.${content.integrity}.json`);\n  if (!import.meta.dev && import.meta.server) {\n    addPrerenderPath(apiPath);\n  }\n  if (shouldUseClientDB()) {\n    const db = await import(\"./client-db.js\").then((m) => m.useContentDatabase());\n    return db.fetch(query);\n  }\n  const _query = content.experimental.stripQueryParameters ? void 0 : `_params=${encodeURIComponent(jsonStringify(params))}&previewToken=${useContentPreview().getPreviewToken()}`;\n  const data = await $fetch(apiPath + \"?\" + _query, { method: \"GET\", responseType: \"json\" });\n  if (typeof data === \"string\" && data.startsWith(\"<!DOCTYPE html>\")) {\n    throw new Error(\"Not found\");\n  }\n  return data;\n};\nexport function queryContent(query, ...pathParts) {\n  const { content } = useRuntimeConfig().public;\n  const queryBuilder = createQuery(createQueryFetch(), {\n    initialParams: typeof query !== \"string\" ? query : {},\n    legacy: true\n  });\n  let path;\n  if (typeof query === \"string\") {\n    path = withLeadingSlash(joinURL(query, ...pathParts));\n  }\n  const originalParamsFn = queryBuilder.params;\n  queryBuilder.params = () => {\n    const params = originalParamsFn();\n    if (path) {\n      params.where = params.where || [];\n      if (params.first && (params.where || []).length === 0) {\n        params.where.push({ _path: withoutTrailingSlash(path) });\n      } else {\n        params.where.push({ _path: new RegExp(`^${path.replace(/[-[\\]{}()*+.,^$\\s/]/g, \"\\\\$&\")}`) });\n      }\n    }\n    if (!params.sort?.length) {\n      params.sort = [{ _stem: 1, $numeric: true }];\n    }\n    if (content.locales.length) {\n      const queryLocale = params.where?.find((w) => w._locale)?._locale;\n      if (!queryLocale) {\n        params.where = params.where || [];\n        params.where.push({ _locale: content.defaultLocale });\n      }\n    }\n    return params;\n  };\n  return queryBuilder;\n}\n"],"names":["_a"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}